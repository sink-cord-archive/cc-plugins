(function(o,f,h,i,p,y,l){"use strict";function d(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var c=d(o),w=d(h);const g=/[^\S\r\n]*?\r?\n[^\S\r\n]*?\*[^\S\r\n]?/,S=/^\\@/;function E(e){try{return JSON.parse(e)}catch{}}function T(e){const t=e.split(`
`)[0];if(t.includes("//META"))return M(e);if(t.includes("/**"))return N(e);throw new Error("META was not found.")}function M(e){const t=e.split(`
`)[0],n=t.substring(t.lastIndexOf("//META")+6,t.lastIndexOf("*//")),s=E(n);if(!s)throw new Error("META could not be parsed.");if(!s.name)throw new Error("META missing name data.");return s}function N(e){const t=e.split("/**",2)[1].split("*/",1)[0],n={};let s="",r="";for(const a of t.split(g))if(a.length!==0)if(a.charAt(0)==="@"&&a.charAt(1)!==" "){n[s]=r;const u=a.indexOf(" ");s=a.substr(1,u-1),r=a.substr(u+1)}else r+=" "+a.replace("\\n",`
`).replace(S,"@");return n[s]=r.trim(),delete n[""],n}var R=async(e,t)=>{const n=await(await fetch(new URL(e,t).href)).text();return{id:`${t}___${e}`,CSS:n,...T(n)}};async function x(e){const t=new URL("repo.json",e).href,n=await(await fetch(t)).json();if(!n.themes||n.themes?.length===0)throw new Error("No themes found in repo");if(!n.meta)throw new Error("No repo metadata");if(!n?.meta.name)throw new Error("Repo did not have a name");return n}var _=async e=>{const t=await x(e),n=await Promise.all(t.themes.map(s=>R(s,e)));return{manifest:t,themes:n}};function v(e){if(!e?.id||!e.CSS)throw new Error("theme was missing either id or css.");const t=f.injectCSS(e.CSS);c.default.state.ghost.unpatchCache.set(e.id,t)}function m(){c.default.state.ghost.unpatchCache.forEach(e=>e?.()),c.default.state.ghost.unpatchCache.clear()}var D=async()=>{if(!o.persist.ghost.repos||!o.persist.ghost.themes)return m;const e=o.persist.ghost.repos,t=await Promise.all(e.map(async r=>[r,await _(r)])),n=[];t.forEach(([r,a])=>{n.push(...a.themes.map(u=>({...u,repoUrl:r})))});const s=o.persist.ghost.themes.filter(r=>r.enabled);return n.filter(r=>s.some(a=>r.id===a.id)).forEach(v),m},A=()=>(c.default.state=w.default.make({unpatchCache:new Map}),()=>{c.default.state=void 0,delete c.default.state});const C=i.findByDisplayName("FormTitle"),L=i.findByDisplayName("FormText"),B=i.findByDisplayName("FormSection");i.findByDisplayName("FormDivider"),i.findByProps("Sizes","Colors","Looks","DropdownSizes"),i.findByDisplayName("TextInput");var F=()=>(p.useNest(o.persist),l.React.createElement(y.ErrorBoundary,null,l.React.createElement(B,null,l.React.createElement(C,{tag:"h1"},"Cumstain"),(o.persist.ghost.themes??[]).map(e=>l.React.createElement(L,null,e.name))))),O=()=>f.after("getPredicateSections",i.findByDisplayName("SettingsView").prototype,(e,t)=>{if(t[1]?.section!="My Account")return;let n=t.findIndex(s=>s.section=="CUMCORD_PLUGINS")+1;return t.splice(n,0,{section:"ysink_stain_CUMSTAIN",label:"Themes",element:F}),t}),U=({persist:e})=>{let t=[];return{onLoad:async()=>{t.push(O(),A(),await D())},onUnload:()=>t.reduceRight((n,s)=>s?.(),null)}};return U})(cumcord.pluginData,cumcord.patcher,cumcord.modules.internal.nests,cumcord.modules.webpack,cumcord.utils,cumcord.ui.components,cumcord.modules.common);
